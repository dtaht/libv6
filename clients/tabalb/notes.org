* There are ~10 global variables
* Everything is optimized for vector processing
** aligned to natural boundaries
** always in tables large enough for a prefetch or dma overrun
* Everything is a table - with frequently accessed types in their own table indexed separately
** all classification is on the way in
** No pointers as much as feasible (I am going to be lazy and violate this a few times)
* C bitfields are used where appropriate, masks elsewhere
** Very small values everywhere - think hardware or 16 bit microcontroller
* Code sharing is maximized
* Internationalization will be enabled
** But string sharing across modules is hard
* C11 features like structure return are used extensively
** Often structures are returned instead of using the stack
In the case of NEON and SSE we can slam the structures into existing registers.
In the case of hardware certain things end up in registers anyway.
Yes, structures are a PITA in regular C, and hard on the compiler and code author.
* trap handler
I am thinking more and more that instead of a classic goto err thing, we should
define and have a trap handler instead. For example, in the future there might 
be more and different ae encodings than we know how to handle.

* Ipv4 vs IPv6
It is making more and more sense to have disjoint ipv4 and ipv6 tables
The metadata remains the same, but the other index is referenced from an
altenate starting point. How to do this?
* Direct calls to library functions are wrapped
** Because at some point I'm going to violate the std ABI
There will be a few globals kept always in registers
** Register Set essentially looks like this
FLAGS
TRAPS
BASEOFFSET
V6ADDRS
V4ADDRS
V6META
V4META
INTERFACES
ROUTERS
ROUTES

* popcount rather than hashes
Originally I was going to use a hasher. popcnt has a great property 
in that if two popcounts are different, we know things are different.

The algorithm is becoming more similar to a classic skip list 
every day. My intent is to do generational garbage collection
on a tick (either per packet or time based).

* Plenty of registers

Experimentation with the e-gcc C compiler showed that the
registers  identified  as  requiring  “Callee  Saved”  (22  of  them)
are only available if the special word “register” is prepended
to local  variable declarations.  The four registers  identified as
“Reserved for constants” are not allocated and hence not used
in any C code fragments we inspected.
* Merging routes
** popcount is hamming distance
so it is guaranteed to go down as you seach /64 /63 /62

* TODO memoized queries

Multiple query types are essentially memoizable - 

* Multiple Parallallea

Well, what do you do when you run out of space 64,000 routes?
You start up a garuntted to be disjoint set on another cpu,
much like being generational, you send a generation onwards
with a clear filter between them. One clear filter is:

prefix/plen - throw all possible matches against this 
prefix less than plen into another table entirely

* Disjoint portions of the data set
* truth

* Combiner for routes, using the hamming distance
and triggering the garbage collector at each step outwards.

append combined routes with a distance to the next possible route

we establish a combining state, where we see that as a possibility
looking back at the routes we had

*** with an internal compressed routing table we can further optimize
and only export to the kernel "the solution", which in many cases degrades
to just the retracted routes and a default route.

We can also spread out existing route announcements sanely across the compressed
table over a longer interval in the routing announcements

and one day, just announce the aggregated routes as "true", and treat
the arrival of a subset route (with, perhaps a different metric) as the 
onset of uncertainty.

* Compression and eq and volume changes

Thinking aoubt this as an audio problem, with a very low hz is helpful

* plugin traffic generator
* plugin traffic monitor
* plugin wifi stats
** plugin for other stuff

* Tests

Test performance of insert/delete/update/search mechanisms

* Ringbuffer - found one here for c11 (pthreads)

https://github.com/rmind/ringbuf/tree/master/src

but I still want *my* ringbuffer which was a header file that took fixed length quantities and 
used the mmap trick, and had a few other features like high and low watermarks.

https://github.com/stv0g/c11-queues.git looks better. Still - fixed length 
quantities, generated at compile time, would be better, as well as a high/low watermark
feature to find balance, and the tests at least, are written for x86 only.

* TODO I still need to look over librcu.

* TODO Get a reasonably generic get_cycles routine.

* New C99 trick of the month %zd

%zd does the right thing for where %ld and %d are different.
%zu as well.

There's support in gcc and clang and glib and newlib

not sure if it is in musl

* An API begins to emerge

This whole thing is a bit much for ddpd, but the table management
gets simpler the more I abstract things.

split_prefix
dump_prefixes

* macaddr_t table

One of my dreams has long been to implement the rotating mac hash first described
to me by fred baker 4+ years ago. It can try to create a perfect hash, too.

* While I'm at it, printf abuse

%A Address
%P Prefix
%M Macaddr

Then I can pass a string like

pass("%P via %A via %A over %M", prefix, address, nexthop, macaddr);

and not have to copy OR format those variables;

Or write a more specialized one.

* FMA - floating point metrics

The missing "4th" additive field could be replaced by a user specified one

And I'm dying to use a FMA somewhere - the idea of multiplying a result by a
smoothing factor that is actually floating point is a cool idea.

Also we need to use saturating arithmetic carefully.

* Partition based on plen for city-scale routing

As the only 64k bounds that are likely to be exceeded is the total number of addresses
or routes, we can easily partition off a separate virtual co-processor to handle
that, and still share data on interfaces, next hops, and so on.

You can find nearly any division that works, and split off the work as it
happens

fc::/7
172.26.16.0/16
172.26.26.0/16

all represent clear partitions of work.

We can have a number of virtual processors much larger than the actual number of
processors and swap them in and out as needed.

You can, in general, always do this, even if you don't actually have to.

* combining pop and plen

If I made plen always negative a plen of 0 = 0, -128 = ?
I want to distinguish between a source specific and non source specific route

// https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html#g_t_005f_005fatomic-Builtins
// Built-in Function: type __atomic_fetch_xor (type *ptr, type val, int memorder)

* Interruptable garbage collection

At any point a garbage collection attempt can be interrupted, discarded, and
retried. As opposed to "stop the world". 

gc also tries to keep track of how much work is left, in case stopping the
world is needed.

* Merge sort

It is inefficient to insert each new route and metric one at a time, when
up to 80 arrive in a single packet. Instead, all routes are staged, partitioned,
then merged.

* Native endian

I would rather like to use native endianess, converting on the way in and out
as a means to make memcmp-like operations mildly easier to think about.

* partitioner

pushing the partitioning into netlink would be nice -
"give me only things that affect these subnets".

* rules extension for sets
in-set
aorr(a,b,c,d) action
aand

* Strides and minimal table wandering instructions

Originally I thought I'd generate one codebase per function, indexing off of the
globally reserved register for that function.

as I think about it there are a limited number of strides (4,8,16,64?) and truth
values, and so we are probably better off with one generated function per stride
on some architectures, and use an index register per se' more directly, with
post-autoincrement, where available.

this also lines up well with thumb (bottom 8 registers are 16 bit instructions),
adapteva (same), and on x86_64 it's an extra byte per higher reg, also.

I honestly can't remember if the idx register concept survived past 386 at the moment.

* For_each_bla

no: 
stagger(cmd,op,timeval);
stagger(cmd,op,timeval) {
whichcores(mask);
multicast(cmd,random,op,timeval)
}
cast

* Use select profiligately
actually, epoll would be better

* --protocol-extensions
ae for aggregation
ae lying - gradually increase the metric of a smaller route while holding the
aggregate low until the listening router has a brief phase of expiring the route
personally
and also announcing via normal ae that aggregated route
unicast hello
hello with stats
wait for hellos
udp-lite for route transfers - we have a basic fq problem in that we want 
our command channel for heartbeats and a data channel for route transfers

We *could* listen on another port. But udp-lite is "just there".

* BPF filter on interfaces? One netlink socket per interface?
* Snoop on traffic? Count routes that I got?

Even with unicast route transfers we can listen in on a raw socket on wifi
tcpdump ip6 proto udp port 6696 or ( proto udplite port 6696) source address
that's not me. 

parasitic

Can we turn off udp checksumming? Can we use raw checksumming? Can we just
grab stuff at the mac80211 layer giving us the qos fields?

Can we deeply inspect the packet? (42?) ? look for a hash? Get the ipclass?
can we at least filter out all the nonipv4 traffic?

char *opt;
opt = "eth0";
setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, opt, 4);

My application is running on CentOS 5.5. I'm using raw socket to send data:

sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
if (sd < 0) {
  // Error
}
const int opt_on = 1;
rc = setsockopt(m_SocketDescriptor, IPPROTO_IP, IP_HDRINCL, &opt_on, sizeof(opt_on));
if (rc < 0) {
  close(sd);
  // Error
}
struct sockaddr_in sin;
memset(&sin, 0, sizeof(sin));
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = my_ip_address;

if (sendto(m_SocketDescriptor, DataBuffer, (size_t)TotalSize, 0, (struct sockaddr *)&sin, sizeof(struct sockaddr)) < 0)  {
  close(sd);
  // Error
}

#define SERVERPORT 5555
...
struct ifreq ifr;


/* Create the socket */
sd = socket(AF_INET, SOCK_STREAM, 0);
if (sd < 0) 
{
    printf("Error in socket() creation - %s", strerror(errno));
}

/* Bind to eth1 interface only - this is a private VLAN */
memset(&ifr, 0, sizeof(ifr));
snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "eth1");
if ((rc = setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, (void *)&ifr, sizeof(ifr))) < 0)
{
    perror("Server-setsockopt() error for SO_BINDTODEVICE");
    printf("%s\n", strerror(errno));
    close(sd);
    exit(-1);
}

/* bind to an address */
memset(&serveraddr, 0x00, sizeof(struct sockaddr_in));
serveraddr.sin_family = AF_INET;
serveraddr.sin_port = htons(SERVERPORT);
serveraddr.sin_addr.s_addr = inet_addr("9.1.2.3");

int rc = bind(sd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));

* Next up popcount!

implemented as a generic routine for all types using C11 generics.
I hope.

Then, off to review the table logic. I may adopt go's convention
for identifying these "registers" here, as they *are* global symbols.

Definately, treating the ipv4 and ipv6 paths as separate is looking like a big win.

* HAT-trie?

https://github.com/malbrain/HatTrie

I would like to plunk some alternative to qsort into mainline babeld.

This might be worthwhile trying

* While I am endlessly appending stuff

Another long stalled out effort was the ipv6 timestamp header.

There was source for this, as I recall... and boy could I use it. I could punt
timestamping to kernels that supported it. And on a p2p link, the header might
pass.


https://www.ietf.org/proceedings/87/slides/slides-87-6man-4.pdf

And another:

http://www.dcs.gla.ac.uk/~dp/pubs/Pezaros-NOMS04-CRC.pdf

* I incidentally hit upon a good way to experiment with babel with less fear

switch the proto I'm using to UDPLITE
* started at popcount
and made a mess of it
* Endian

I really, really, really want to convert endianness on the way in and way out.

But as near as I can tell by leveraging popcount and plen first,
I can just consider > < 

but I need to think about it.

Similarly, memcmp in sse routines

* TODO going back to ddpd

should roll the command line api while fresh on my mind
also - api split prefix/join prefix - uses factory pattern

* TODO EBPF compiler in llvm

What can I make EBPF do?

faster expression for

tcpdump ip6 and '( proto udp or proto 138 )' and offset? portnumber = 6696 and notme

but I actually want to start using extension headers so ip6 chain?


    setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER_EBPF, &prog_id, sizeof(prog_id));

* options

define run-yacc =
yacc $(firstword $^)
mv y.tab.c $@
endef

* adapteva notes

e-gcc
ifeq($(CC),e-gcc) 
CFLAGS +=-m1reg-r63 - use -63 for negative constants
CFLAGS +=-falign-loops=8
CFLAGS +=-falign-functions=8
endif

linker, alloc_size, cold,flatten,always inline, malloc, pure, section
gcc compiler directives

--entry=entry

__core_row_
__core_col__
__stack_start__

http://adapteva.com/docs/epiphany_sdk_ref.pdf pg 49

asm(".global __core_row__;");
asm(".set __core_row__,0x20;");
asm(".global __core_col__;");
asm(".set __core_col__,0x24;");

* Idea: Generational kernel tables.

Use 2 specific kernel tables, send all routes into the new one,
then change the rule atomically, flush all routes from the old one.

Dealing with netlink's semantics is a pain in the ass.

IF routes get rejected (pointing somewhere wrong), push them on a local stack
and retry. Ideally the route insertion process is sorted correctly, but who
knows.

* Auto generate flags arguments big and little endian and a means to print them out.

* Aggregating routes

** join? adjecent? I have a better name for this

* x86 notes

** declaring my calloc
For instance,

void* my_calloc(size_t, size_t) __attribute__((alloc_size(1,2)))
void* my_realloc(void*, size_t) __attribute__((alloc_size(2)))
declares that my_calloc returns memory of the size given by the product of parameter 1 and 2 and that my_realloc returns memory of the size given by parameter 2.
** really wanted to violate the C calling convention
and just return a set flags register in several cases


artificial

useful:
https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes

void* my_alloc1(size_t) __attribute__((assume_aligned(16)))
void* my_alloc2(size_t) __attribute__((assume_aligned(32, 8)))

** cold optimizes for size not speed and puts in a separate section
** ffreestanding or -fno-builtin might shut the compiler up on my printfs
-Wformat
** malloc tells the compiler I can alias stuff
** const is not allowed to read global memory.

and I want to violate that, selectively. Someone stop me!
** hot gets optimized extensively yes!
** flatten
** no_split_stack
** bnd_instrument looks USEFUL for doing bounds checking
fchkp-instrument-marked-only
extern void *
mymalloc (size_t len) __attribute__((returns_nonnull));
** simd is actually a keyword...
simd("mask")

** Way more compiler options than I want

# -mregparm=num
# -msseregparm=
# -mcx16 - have 16 byte cmpxchg
# -msahf
# -mmovbe big endian optimization
# -mcrc32 - used in google's hash
# -mno-align-stringops - don't bother with alignment
# -minline-all-stringops
# -fomit-frame-pointer
# -mfpmath=sse
# sseregparm is a function attribute I can declare. Yea!
# -mno-ieee-fp
# __builtin_types_compatible_p
# profile feedback via: -fprofile-arcs
# __builtin_trap
# __builtin_parity
# __builtin_ffsl find first set long
# __builtin_clzl
# __builtin_bswap64
# https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html
# target(abm)

# what does the https://github.com/adobe-flash/crossbridge/blob/master/llvm-gcc-4.2-2.9/gcc/testsuite/gcc.target/i386/fastcall-sseregparm.c
# fast call do?
# no_caller_saved_registers
# void __f () { /* Do something. */; }
# void f () __attribute__ ((weak, alias ("__f")));
