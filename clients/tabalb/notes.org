* There are ~10 global variables
* Everything is optimized for vector processing
** aligned to natural boundaries
** always in tables large enough for a prefetch or dma overrun
* Everything is a table - with frequently accessed types in their own table indexed separately
** all classification is on the way in
** No pointers as much as feasible (I am going to be lazy and violate this a few times)
* C bitfields are used where appropriate, masks elsewhere
** Very small values everywhere - think hardware or 16 bit microcontroller
* Code sharing is maximized
* Internationalization will be enabled
** But string sharing across modules is hard
* C11 features like structure return are used extensively
** Often structures are returned instead of using the stack
In the case of NEON and SSE we can slam the structures into existing registers.
In the case of hardware certain things end up in registers anyway.
Yes, structures are a PITA in regular C, and hard on the compiler and code author.
* trap handler
I am thinking more and more that instead of a classic goto err thing, we should
define and have a trap handler instead. For example, in the future there might 
be more and different ae encodings than we know how to handle.

* Ipv4 vs IPv6
It is making more and more sense to have disjoint ipv4 and ipv6 tables
The metadata remains the same, but the other index is referenced from an
altenate starting point. How to do this?
* Direct calls to library functions are wrapped
** Because at some point I'm going to violate the std ABI
There will be a few globals kept always in registers
** Register Set essentially looks like this
FLAGS
TRAPS
BASEOFFSET
V6ADDRS
V4ADDRS
V6META
V4META
INTERFACES
ROUTERS
ROUTES

* popcount rather than hashes
Originally I was going to use a hasher. popcnt has a great property 
in that if two popcounts are different, we know things are different.

The algorithm is becoming more similar to a classic skip list 
every day. My intent is to do generational garbage collection
on a tick (either per packet or time based).

* Plenty of registers

Experimentation with the e-gcc C compiler showed that the
registers  identified  as  requiring  “Callee  Saved”  (22  of  them)
are only available if the special word “register” is prepended
to local  variable declarations.  The four registers  identified as
“Reserved for constants” are not allocated and hence not used
in any C code fragments we inspected.
* Merging routes
** popcount is hamming distance
so it is guaranteed to go down as you seach /64 /63 /62

* TODO memoized queries

Multiple query types are essentially memoizable - 

* Multiple Parallallea

Well, what do you do when you run out of space 64,000 routes?
You start up a garuntted to be disjoint set on another cpu,
much like being generational, you send a generation onwards
with a clear filter between them. One clear filter is:

prefix/plen - throw all possible matches against this 
prefix less than plen into another table entirely

* Disjoint portions of the data set
* truth

* Combiner for routes, using the hamming distance
and triggering the garbage collector at each step outwards.

append combined routes with a distance to the next possible route

we establish a combining state, where we see that as a possibility
looking back at the routes we had

*** with an internal compressed routing table we can further optimize
and only export to the kernel "the solution", which in many cases degrades
to just the retracted routes and a default route.

We can also spread out existing route announcements sanely across the compressed
table over a longer interval in the routing announcements

and one day, just announce the aggregated routes as "true", and treat
the arrival of a subset route (with, perhaps a different metric) as the 
onset of uncertainty.

* Compression and eq and volume changes

Thinking aoubt this as an audio problem, with a very low hz is helpful

* plugin traffic generator
* plugin traffic monitor
* plugin wifi stats
** plugin for other stuff

* Tests

Test performance of insert/delete/update/search mechanisms

* Ringbuffer - found one here for c11 (pthreads)

https://github.com/rmind/ringbuf/tree/master/src

but I still want *my* ringbuffer which was a header file that took fixed length quantities and 
used the mmap trick, and had a few other features like high and low watermarks.

https://github.com/stv0g/c11-queues.git looks better. Still - fixed length 
quantities, generated at compile time, would be better, as well as a high/low watermark
feature to find balance, and the tests at least, are written for x86 only.

* TODO I still need to look over librcu.

* TODO Get a reasonably generic get_cycles routine.

* New C99 trick of the month %zd

%zd does the right thing for where %ld and %d are different.
%zu as well.

There's support in gcc and clang and glib and newlib

not sure if it is in musl
