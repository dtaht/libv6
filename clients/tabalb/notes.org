* There are ~10 global variables
* Everything is optimized for vector processing
** aligned to natural boundaries
** always in tables large enough for a prefetch or dma overrun
* Everything is a table - with frequently accessed types in their own table indexed separately
** all classification is on the way in
** No pointers as much as feasible (I am going to be lazy and violate this a few times)
* C bitfields are used where appropriate, masks elsewhere
** Very small values everywhere - think hardware or 16 bit microcontroller
* Code sharing is maximized
* Internationalization will be enabled
** But string sharing across modules is hard
* C11 features like structure return are used extensively
** Often structures are returned instead of using the stack
In the case of NEON and SSE we can slam the structures into existing registers.
In the case of hardware certain things end up in registers anyway.
Yes, structures are a PITA in regular C, and hard on the compiler and code author.
* trap handler
I am thinking more and more that instead of a classic goto err thing, we should
define and have a trap handler instead. For example, in the future there might 
be more and different ae encodings than we know how to handle.

* Ipv4 vs IPv6
It is making more and more sense to have disjoint ipv4 and ipv6 tables
The metadata remains the same, but the other index is referenced from an
altenate starting point. How to do this?
* Direct calls to library functions are wrapped
** Because at some point I'm going to violate the std ABI
There will be a few globals kept always in registers
** Register Set essentially looks like this
FLAGS
TRAPS
BASEOFFSET
V6ADDRS
V4ADDRS
V6META
V4META
INTERFACES
ROUTERS
ROUTES

* popcount rather than hashes
Originally I was going to use a hasher. popcnt has a great property 
in that if two popcounts are different, we know things are different.

* Plenty of registers

Experimentation with the e-gcc C compiler showed that the
registers  identified  as  requiring  “Callee  Saved”  (22  of  them)
are only available if the special word “register” is prepended
to local  variable declarations.  The four registers  identified as
“Reserved for constants” are not allocated and hence not used
in any C code fragments we inspected.
* Merging routes
** popcount is hamming distance
so it is guaranteed to go down as you seach /64 /63 /62

* TODO memoized queries
* Multiple Parallallea
Well, what do you do when you run out of space 64,000 routes?
You start up a garuntted to be disjoint set on another cpu,
much like being generational, you send a generation onwards


* Disjoint portions of the data set
* truth
* Combiner for routes, using the hamming distance
and triggering the garbage collector at each step outwards.

append combined routes with a distance to the next possible route

we establish a combining state, where we see that as a possibility
looking back at the routes we had

*** with an internall compressed routing table we can further optimize
*** and only 

we can also spread out existing route announcements sanely across the compressed
table over a longer interval

* Compression and eq and volume changes

Thinking aoubt this as an audio problem, with a very low hz is helpful

* plugin traffic generator
* plugin traffic monitor
* plugin wifi stats
** plugin for other stuff
